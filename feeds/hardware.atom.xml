<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>잘 밤에 쓸데없는 생각하기... - Hardware</title><link href="https://ujuc.github.io/" rel="alternate"></link><link href="https://ujuc.github.io/feeds/hardware.atom.xml" rel="self"></link><id>https://ujuc.github.io/</id><updated>2018-03-11T12:00:45+09:00</updated><subtitle>Anythink, Everythink!</subtitle><entry><title>Edison - Bluetooth 설정</title><link href="https://ujuc.github.io/2016/06/22/edison_-_bluetooth_seor-jeong/" rel="alternate"></link><published>2016-06-22T00:12:00+09:00</published><updated>2016-06-22T00:12:00+09:00</updated><author><name>ujuc</name></author><id>tag:ujuc.github.io,2016-06-22:/2016/06/22/edison_-_bluetooth_seor-jeong/</id><summary type="html">&lt;p&gt;오래된 글이다 그냥 내놓는다. IBM에서 나왔던 Edison 에서 bluetooth 설정에 관련된 내용이다.&lt;/p&gt;</summary><content type="html">&lt;p&gt;오래된 글이다 잠시 IoT로 하면서 기본적으로 설정하면서 나왔던 것. 정리한 내용이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="bluetooth"&gt;Bluetooth 설정&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Edison 에서는 Bluetooth 제어 모듈로 BlueZ를 사용하고 있다.&lt;/li&gt;
&lt;li&gt;리눅스에서 다쓴다.&lt;/li&gt;
&lt;li&gt;그런데 개발이 중단된것같은 느낌이 들긴했다. 그냥 느낌임.&lt;/li&gt;
&lt;li&gt;패키지 구조는 아래와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_1"&gt;설정&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;간단하다. 기본적으로 Bluez가 설치가되어 있으니 그냥 켜주기만하면 된다.&lt;/li&gt;
&lt;li&gt;먼저 &lt;code&gt;bluetooth&lt;/code&gt; 데몬을 실행시켜준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# systemctl stop bluetooth&lt;/span&gt;
&lt;span class="err"&gt;# systemctl start bluetooth&lt;/span&gt;
&lt;span class="err"&gt;# systemctl status bluetooth&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;블루투스를 사용할 수 있도록 모듈을 활성화시켜준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# rfkill list&lt;/span&gt;
&lt;span class="err"&gt;# rfkill unblock bluetooth&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_2"&gt;어플리케이션 사용&lt;/h2&gt;
&lt;h3 id="bluetoothctl"&gt;&lt;code&gt;bluetoothctl&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쉘형식으로 접근하여 블루투스를 설정할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;agent&lt;/code&gt;를 설정하여 범위를 줄여서 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;나머지 사용법은 &lt;a href="http://download.intel.com/support/edison/sb/edisonbluetooth_331704004.pdf"&gt;블루투스 가이드&lt;/a&gt;를 보도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hciconfig"&gt;&lt;code&gt;hciconfig&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ifconfig&lt;/code&gt;와 같은 &lt;code&gt;hci&lt;/code&gt;관련 디바이스들의 상태를 확인할 수 있는 툴이다.&lt;/li&gt;
&lt;li&gt;사용법은 동일하며, 몇몇 설정이 되어있어야한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hciconfig hci0 sspmode 1&lt;/code&gt;: &lt;code&gt;hci0&lt;/code&gt;에 간단한 페어링 설정을 활성화 한다는 의미이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hciconfig hci0 sspmode&lt;/code&gt;: &lt;code&gt;hci0&lt;/code&gt;에 설정된 간략한 페어링 설정이 어떻게 되어있는지를 확인한다는 것.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hciconfig hci0 lestates&lt;/code&gt;: LE 모듈 관련되서 설정들을 확인할 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hcitool"&gt;&lt;code&gt;hcitool&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;간단한 명령어로 &lt;code&gt;bluetoothctl&lt;/code&gt;을 사용하지 않고서 작업을 진행할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hcitool scan&lt;/code&gt;을 이용하여 블루투스 기기를 검색할 수 있다.&lt;/li&gt;
&lt;li&gt;옵션들을 이용해서 더 다양한 작업들이 가능하게 해놨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pybluez"&gt;&lt;code&gt;pybluez&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BlueZ의 Python 라이브러리인데&amp;hellip;&lt;/li&gt;
&lt;li&gt;사람들은 &lt;code&gt;hcitool&lt;/code&gt;을 더 많이 쓰는 것으로&amp;hellip;&lt;/li&gt;
&lt;li&gt;C맵핑을 해놔서 왠만한 작업들은 가능한 것으로 보이나 문서가 빈약하여 사용하기 쉽지 않다.&lt;/li&gt;
&lt;li&gt;뭔가 추가를 하려면 코드를 봐야된다.&lt;/li&gt;
&lt;li&gt;그래서 잘안쓰나&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://software.intel.com/en-us/articles/intel-edison-board-getting-started-with-bluetooth"&gt;Intel Edison Board Getting Started with Bluetooth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://download.intel.com/support/edison/sb/edisonbluetooth_331704004.pdf"&gt;Intel Edison Bluetooth Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/karulis/pybluez"&gt;pybluez&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/intel-iot-devkit/edison-guides/wiki"&gt;edison-guies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://software.intel.com/en-us/articles/connecting-to-intel-edison-from-android-with-bluetooth-le-ble"&gt;Connecting to Intel Edison from Android with Bluetooth LE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Hardware"></category><category term="edison"></category><category term="bluetooth"></category><category term="iot"></category></entry><entry><title>TI에서 베터리를 가장 적게 먹는 칩 출시</title><link href="https://ujuc.github.io/2015/03/16/ti-lowpwoer-soc-release/" rel="alternate"></link><published>2015-03-16T23:56:00+09:00</published><updated>2015-04-02T23:05:00+09:00</updated><author><name>ujuc</name></author><id>tag:ujuc.github.io,2015-03-16:/2015/03/16/ti-lowpwoer-soc-release/</id><summary type="html">&lt;p class="first last"&gt;뉴스가 나왔다. 베터리가 필요없는 SOC가 나왔다고, 믿지는 않았다. 그래서
찾아봤다. 역시나... 그져 대기시에만 오랫동안 지낼수 있도록 가장 적은
전력을 사용할뿐...&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="http://www.kidd.co.kr/news/178946"&gt;산업일보&lt;/a&gt; 에 &amp;quot;TI, 베터리 없는 IoT 커넥티비티 구현&amp;quot; 이라는 뉴스가 올라왔다.
뭔일인가 해서 봤더니만... SimpleLink라는 초전력 플랫폼을 개발했다는 소리였다.&lt;/p&gt;
&lt;p&gt;기본 코어는 ARM® Cortext®-M3 MCU를 사용했고, 플래시 / RAM, ADC, 이것 저것들을
같이 묶은 것에 통신은 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Bluetooth_low_energy"&gt;Bluetooth Low Energy(BLE)&lt;/a&gt;, &lt;a class="reference external" href="http://en.wikipedia.org/wiki/ZigBee"&gt;ZigBee®&lt;/a&gt;, &lt;a class="reference external" href="http://en.wikipedia.org/wiki/6LoWPAN"&gt;6LoWPAN&lt;/a&gt;,
sub-1GHz, &lt;a class="reference external" href="https://docs.zigbee.org/zigbee-docs/dcn/09/docs-09-5231-03-rmwg-understanding-zigbee-rf4ce.pdf"&gt;ZigBee RF4CE™&lt;/a&gt;, 최대 5Mbps 고유모드로 지원한다고 한다.&lt;/p&gt;
&lt;p&gt;제목에서는 베터리가 없다고 말을 했지만.. 침 설계된 내용들을 확인해보면...&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Active-mode RX: 5.9 mA&lt;/li&gt;
&lt;li&gt;Active-mode TX at 0 dBm: 6.1 mA&lt;/li&gt;
&lt;li&gt;Active-mode Tx at +5 dBm: 9.1 mA&lt;/li&gt;
&lt;li&gt;Active-mode MCU: 61 µA/MHz&lt;/li&gt;
&lt;li&gt;Active-mode MCU: 48.5 CoreMark/mA&lt;/li&gt;
&lt;li&gt;Active-mode Sensor Controller: 8.2 µA/MHz&lt;/li&gt;
&lt;li&gt;Standby: 1 µA (RTC Running and RAM/CPU Retention)&lt;/li&gt;
&lt;li&gt;shutdown: 100 nA (Wakeup on External Events)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;적게 먹기는 한다. 전력은 조금 먹지만, 전압이 1.8에서 3.8V라고 적혀있는 걸보면...
건전지 2개는 들어가야되는...&lt;/p&gt;
&lt;p&gt;이 아이드은 셈플로 몇개 받을 수 있는지 한번 알아볼까... 최대 GPIO도 31개면
괜찮은데...&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ti.com/product/cc2630"&gt;CC2630&lt;/a&gt; : ZigBee, 6LoWPAN&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ti.com/product/cc2640"&gt;CC2640&lt;/a&gt; : Bluetooth Smart&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ti.com/product/cc2650"&gt;CC2650&lt;/a&gt; : Bluetooth Smart, ZigBee, 6LoWPAN, ZigBee RF4CE&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ti.com/product/cc1310"&gt;CC1310&lt;/a&gt; : Sub-1GHz&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ti.com/product/cc2620"&gt;CC2620&lt;/a&gt; : ZigBee RF4CE&lt;/li&gt;
&lt;/ul&gt;
</content><category term="Hardware"></category><category term="ti"></category><category term="chip"></category><category term="iot"></category><category term="m3"></category><category term="arm"></category><category term="ble"></category><category term="low energy"></category></entry><entry><title>RAM 리뷰에서 본 버전별 특성</title><link href="https://ujuc.github.io/2015/02/09/RAM-reive/" rel="alternate"></link><published>2015-02-09T00:00:00+09:00</published><updated>2015-03-31T21:47:00+09:00</updated><author><name>ujuc</name></author><id>tag:ujuc.github.io,2015-02-09:/2015/02/09/RAM-reive/</id><summary type="html">&lt;p class="first last"&gt;RAM 사양에 대한 내용들로 그냥 기억용임.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;RSS에서 &lt;a class="reference external" href="http://www.anandtech.com/show/8959/ddr4-haswell-e-scaling-review-2133-to-3200-with-gskill-corsair-adata-and-crucial"&gt;DDR4 Haswell-E Scaling Review&lt;/a&gt;: 2133 to 3200 with G.Skill, Gorsair,
ADATA and Crucial 에서 글이올라왔길레 봤는데...&lt;/p&gt;
&lt;p&gt;어떤분께서 그렇게 말씀하시던 RAM이 버전업되면서 달라지 내용과 다른 점이 보여서
머릿속 내용을 업데이트하는 겸해서 작성해두는 내용이다.&lt;/p&gt;
&lt;div class="section" id="dram-comparison"&gt;
&lt;h2&gt;DRAM Comparison&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="10%" /&gt;
&lt;col width="22%" /&gt;
&lt;col width="31%" /&gt;
&lt;col width="36%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class="head"&gt;Low Voltage&lt;/th&gt;
&lt;th class="head"&gt;Standard Voltage&lt;/th&gt;
&lt;th class="head"&gt;Performance Voltage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;DDR&lt;/td&gt;
&lt;td&gt;1.80V&lt;/td&gt;
&lt;td&gt;2.50V&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DDR2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;1.80V&lt;/td&gt;
&lt;td&gt;1.90V&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DDR3&lt;/td&gt;
&lt;td&gt;1.35V&lt;/td&gt;
&lt;td&gt;1.50V&lt;/td&gt;
&lt;td&gt;1.65V&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DDR4&lt;/td&gt;
&lt;td&gt;1.05V&lt;/td&gt;
&lt;td&gt;1.20V&lt;/td&gt;
&lt;td&gt;1.35V&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="bandwidth-comparison"&gt;
&lt;h2&gt;Bandwidth Comparison&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="7%" /&gt;
&lt;col width="19%" /&gt;
&lt;col width="19%" /&gt;
&lt;col width="12%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="23%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class="head"&gt;Bus Clock&lt;/th&gt;
&lt;th class="head"&gt;Internal Rate&lt;/th&gt;
&lt;th class="head"&gt;Prefetch&lt;/th&gt;
&lt;th class="head"&gt;Transfer Rate&lt;/th&gt;
&lt;th class="head"&gt;Channel Bandwidth&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;DDR&lt;/td&gt;
&lt;td&gt;100-200 MHz&lt;/td&gt;
&lt;td&gt;100-200 MHz&lt;/td&gt;
&lt;td&gt;2n&lt;/td&gt;
&lt;td&gt;0.20-0.40 GT/s&lt;/td&gt;
&lt;td&gt;1.60-3.20 GBps&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DDR2&lt;/td&gt;
&lt;td&gt;200-533 MHz&lt;/td&gt;
&lt;td&gt;100-266 MHz&lt;/td&gt;
&lt;td&gt;4n&lt;/td&gt;
&lt;td&gt;0.40-1.06 GT/s&lt;/td&gt;
&lt;td&gt;3.20-8.50 GBps&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DDR3&lt;/td&gt;
&lt;td&gt;400-1066 MHz&lt;/td&gt;
&lt;td&gt;100-266 MHz&lt;/td&gt;
&lt;td&gt;8n&lt;/td&gt;
&lt;td&gt;0.80-2.13 GT/s&lt;/td&gt;
&lt;td&gt;6.40-17.0 GBps&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DDR4&lt;/td&gt;
&lt;td&gt;1066-2133 MHz&lt;/td&gt;
&lt;td&gt;100-266 MHz&lt;/td&gt;
&lt;td&gt;8n&lt;/td&gt;
&lt;td&gt;2.13-4.26 GT/s&lt;/td&gt;
&lt;td&gt;12.80-25.60 GBps&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;전압량은 진화될수록 더 낮아져 전력 소비량은 낮아졌고, 속도는 높아졌다. 그런데
어떤분은 전압 부분만 말씀하시던데... 물론 이 내용은 특정 벤더사의 내용일 수도
있지만, 그래도 많은 부분 수정이 된것은 맞은듯. RAM PCB를 보면 특정 핀의 길이가
다른 핀보다 0.5mm만큼 긴것도 특이하다. 특히, 일정 구간에서는 늘어나는 모습을
보여주는 것도...&lt;/p&gt;
&lt;p&gt;자세한건 기사내용을 보는 것이 더 좋은듯.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Hardware"></category><category term="ram"></category><category term="hw"></category><category term="하드웨어"></category></entry><entry><title>KVM on ARM project</title><link href="https://ujuc.github.io/2013/10/14/kvm_on_arm_project/" rel="alternate"></link><published>2013-10-14T11:29:17+09:00</published><updated>2018-03-11T11:29:17+09:00</updated><author><name>ujuc</name></author><id>tag:ujuc.github.io,2013-10-14:/2013/10/14/kvm_on_arm_project/</id><summary type="html">&lt;p&gt;ARM 칩에서 KVM을 사용하는 프로젝트가 있어서 정리한다.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://systems.cs.columbia.edu/projects/kvm-arm/"&gt;Project homepage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ARM 프로세스에서 지원하는 Virtualization을 이용하여 KVM을 올리는 프로젝트 Cortex-15A에서 작업한 내용이 있음. ARM Core는 ARMv7.&lt;/p&gt;
&lt;p&gt;Virtual Open Systems is an innovative, agile and dynamic start-up company operating in embedded Linux, Android, SMP Virtualization and Cloud Computing. 이란다.&lt;/p&gt;
&lt;p&gt;얼마전에 ARMv8에서 KVM을 사용하는 방법도 추가해놨다. (4월에 추가되고 7월에 업데이트 됨.)&lt;/p&gt;
&lt;p&gt;삼성 Exynos 5250를 사용하는 Arndale Board에서 KVM을 이용하여 올렸는데 보면 QEMU가 작동하는 것을 볼 수 있다. 그러나 확실히 속도는 빠르다. 몇배속으로 돌린것인지 아니면 내가 봐왔던 ARM이 느렸던건지..&lt;/p&gt;
&lt;p&gt;&lt;a href="http://youtu.be/yB8bdA2hjYg"&gt;Youtube 동영상&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;덧. 2013.01.11에 작성한 글을 옮기면서 변경사항들이 있어 추가함.&lt;/p&gt;</content><category term="Hardware"></category><category term="arm"></category><category term="kvm"></category><category term="hypervisor"></category></entry><entry><title>PCIutils</title><link href="https://ujuc.github.io/2013/02/21/pciutils/" rel="alternate"></link><published>2013-02-21T12:00:45+09:00</published><updated>2018-03-11T12:00:45+09:00</updated><author><name>ujuc</name></author><id>tag:ujuc.github.io,2013-02-21:/2013/02/21/pciutils/</id><summary type="html">&lt;p&gt;&lt;code&gt;pciutils&lt;/code&gt; 패키지에 대해서 알아본다.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://mj.ucw.cz/sw/pciutils/"&gt;홈페이지&lt;/a&gt; 에서 말하는 건 아래의 영문내용!&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The PCI Utilities are a collection of programs for inspecting and manipulating configuration of PCI devices, all based on a common portable library libpci which offers access to the PCI configuration space on a variety of operating systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;PCI 구성을 위한 것도 이것이 해주고, PCI 관련된 프로그램 모음들도 가지고있는. 그런 페키지 pciuils 여기서 정해주지 않으면 아무리 컴퓨터에 좋은걸 끼웠거나… 이전에 사용하지 않았던 제품을 끼웠다고 해서 리눅스에서 먹어주는 것은 아니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pci-ids.ucw.cz/v2.2/pci.ids"&gt;4월 9일자 pci.ids&lt;/a&gt; 를 검색해보면 아마.. 지원하는 부품들 안에 자신이 사용하는 보드나 이름들이 없다면… 우리 리눅스 버전업을 그만두자.ㅡ.ㅡ…&lt;/p&gt;
&lt;p&gt;PCI 슬롯에서 못읽어들이는데 어쩔수 있냐…..&lt;/p&gt;
&lt;p&gt;뭐 따로 받아서 저것을 추가 해준다면야 사용이 가능하겠지만…………&lt;br&gt;
 왠지 외국에서는 해줄 것같은데.. 우리나라에서는…………&lt;/p&gt;
&lt;p&gt;&lt;em&gt;만약에 추가가 안되어있으면, 내가 추가하면 되겠네?&lt;/em&gt;라는 생각이 문득들어…&lt;br&gt;
찾아봤다. &lt;code&gt;/usr/share/misc/pci.ids&lt;/code&gt; 여기에 있다. 그런데.. 이것만 바꿔주면 되는 것일까??&lt;/p&gt;
&lt;p&gt;음.. 또 찾았다. 어디냐면..&lt;/p&gt;
&lt;p&gt;pciutils 최신버전을 다운받아서 풀었더니 &lt;code&gt;update_pciids.sh&lt;/code&gt;가 있다.ㅡ.ㅡ&lt;br&gt;
그냥 이걸 실행시켜주면 알아서 설치가 될듯한데..&lt;/p&gt;</content><category term="Hardware"></category><category term="pci"></category><category term="linux"></category></entry></feed>